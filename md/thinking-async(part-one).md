# 聊聊异步(-)从yield开始

*一直以来我都非常关注异步, 因为我个人认为, 异步是打造高性能web服务器的最终答案和最佳手段. 异步虽然很棒, 但是理解和应用却不是一件简单的事情, 加上我的确比较笨, 理解和使用异步花了非常长的时间, 因此想在这里分享一下这几年我对异步的经验和理解. 由于我主要使用Nodejs和Python来研究异步, 因此这个系列的文章将会基于Nodejs和Python来解释异步, 逐层揭示异步的许多关键信息*

## 迭代器

在Python这门语言中, 有两种神奇的东西, 迭代器(iterator)与生成器(generator). 你可以简单地将迭代器理解为一个可遍历的对象. 什么样的对象是一个迭代器呢? 很简单, 不需要像java这类静态语言继承一个指定的类才能生成一个迭代器对象. 依靠动态语言强大的**鸭子类型(Duck Typing)**特性, 只需要一个对象实现了\_\_iter\_\_方法, 并且该方法返回了一个拥有\_\_next\_\_方法的对象即可(为了方便我们常常干脆把这两种方法定义在同个类里面), 如下:

```python
class iter_test:
    def __iter__(self):
        self.count = 0
        return self
    
    def __next__(self):
        self.count += 1
        return self.count

    
T = iter_test()
for element in T:
    print(element)
```

非常神奇! 我们把T对象变成了可以被for遍历的东西! 通过这种方式, 我们可以把一个对象轻松地变成可遍历的, 并且可以控制每次for遍历出来的结果, 不像别的语言需要这个东西必须是数组, 键值对或者是其他的限定死的几种数据类型, 比如我们可以这样调用我们设计的对象:

```python
for page in book_object():
    print(page.page_title, page.page_author)
```

不过, 为什么要定义\_\_iter\_\_方法该方法返回了一个拥有\_\_next\_\_方法呢? 直接定义一个\_\_iter\_\_方法返回每次迭代的值不就可以了吗?迭代器到底是怎么工作的?

迭代器的工作原理是, 当new一个迭代器类的时候, 会自动调用类的\_\_iter\_\_方法, 根据使用规定, 解释器拿到一个拥有\_\_next\_\_方法的对象. for语句会自动对该对象执行next(), next函数会调用对象的\_\_next\_\_方法. 所以for语句其实做的真实工作是下面那样的:

```python
object_has_next_method = T.__iter__()
next(object_has_next_method) # 输出1
next(object_has_next_method) # 输出2
```

真实情况是, for语句只处理迭代器. 非迭代器是不能被for识别并遍历的. 那么为什么字典, 数组对象并没有\_\_next\_\_方法却可以被for循环迭代呢?

很简单, 因为对于这些基本数据类型的对象, for会自动给他们加上next方法. 数组的next很明显是按照下标依次遍历, 字典的next很明显也是按照key的顺序输出, 他们该怎么迭代是确定的, 因此可以自动生成next方法.像这类for可识别并自动加上next方法实现的, 只能称为 iterable.

上面的代码很隐晦地告诉我们一件事: 我们可以通过一次又一次地调用next方法, 去遍历完一个对象, 意味着我们可以自由地控制一个循环的开始与暂停, 我们想要这个循环什么时候开始, 什么时候暂停, 什么时候从上次暂停的地方开始, 只要在合适的时候调用next即可.

这也带来了一个问题, 因为迭代器为了每次next都能找回上次next得到的数据, 它不得不保留所有的数据和状态. 如果你的数据很大, 类似一个20M的矩阵那样, 那么传入迭代器的20M的矩阵随着你的每次next一直呆在你的内存里面, 除非迭代器对象被销毁.

## 生成器

生成器是一种特殊的迭代器, 在解决了迭代器问题的基础上, 它带来了有意思的新东西. 你只需要一个yield, 就可以得到一个生成器. 网上介绍生成器常常喜欢用斐波那契数列来演示, 但是我觉得那太复杂了, 这里有更简单的:

```python
def test():
    print('enter test function !')
    yield 1
    print('enter 1 line')
    yield 2
    print('enter 2 line')
    
if __name__ == '__main__':
	t = test()
	print('se')
	next(t)
	print('se1')
	next(t)
	print('se2')
	next(t)
```

输出如下:

```python
se
enter test function !
se1
enter 1 line
se2
enter 2 line
Traceback (most recent call last):
  File "a.py", line 15, in <module>
    next(t)
StopIteration
```

输出揭示了几个事实:

+   函数被调用的时候, 函数并没有执行, 因为解释器发现了函数中包含的yield关键字, 知道了这个函数其实是一个生成器, 返回了一个生成器而不是值
+   第一次执行next的时候, 输出了enter test function !, 然后函数竟然输出了main的se1, 意味者执行到yield的时候函数不再往下执行, 返回到了main!, 第二次执行next的时候, 输出了enter 1 line, 执行到yield的时候, 又返回了main!

也就是说, 每次调用yield, 会从上次yield的地方开始往下执行, 直到下一次遇到yield又被返回, 直到到了函数结束的地方没有yield, 抛出StopIteration异常, 调用结束. 调用者可以轻松地控制函数的流程, 依靠next, 想什么时候执行就什么时候执行, 想什么暂停就什么时候暂停. 这就是生成器. 需要注意的是, yield实现的这种流程状态的切换其实和CPU中断非常像, 都是暂停挂起当前操作并保留上下文, 我怀疑yield的底层实现就是用户态模拟中断行为.

一般来说, 一个函数在调用完成后, 占用的内存和堆栈会被销毁. 而迭代器每次执行到yield的时候会保存堆栈和上下文并将程序的控制权返还给调用方, 下次被调用的时候唤醒上下文并执行, 这看起来很像一个闭包. 相对于迭代器, 由于生成器不需要保存所有的数据, 而是通过保存上下文的方式来查找上次调用的状态, 因此非常节约内存,  并且**控制函数的执行流程更加简单**.

那么生成器到底和异步有什么关系呢? 

从表面上看, 异步其实是在控制代码的流程, 异步最经典的实践手段是pub/sub模式, 也就是监听回调, 比如如下:

```javascript
$('.container').on('click', ()=>{ console.log('click'); })
```

用回调去表达异步有太多的问题, 比如反人类, 比如回调嵌套(callback hell), 比如无法用try...catch...去捕捉异常等等

>   需要澄清的一点是, 回调和异步没有关系, 回调只是异步的一种表现手段, 回调的函数不一定是异步的, 异步也不一定使用回调去表达

关于无法用try...catch...去捕捉异常, 可以阅读 [这里](http://stackoverflow.com/questions/3677783/is-it-possible-to-catch-exceptions-thrown-in-a-javascript-async-callback) , 在监听事件的外围包裹一层try...catch是没有任何作用的, 因为当异步事件触发的时候执行的那个回调函数早就脱离了try...catch..的那个上下文. 如果是浏览器环境你还可以使用window.on('error', function(){ ...//where you will handler error })来处理一下, 不过这也好不到哪里去. 因此在Node中只能在发生异常的时候通过回调函数的参数一层层传出去, 这也是为什么Nodejs要规定回调函数的第一个参数是相关的error错误.

yield也是在控制代码的流程, 阅读上面的文章后我相信你已经明白了这句话. 通过使用yield, 你能够在函数调用IO并等待IO结束返回数据的时候将函数的控制权收回去去做别的事情, IO完毕后再调用next执行这个函数后面还没处理完的事情, 实现异步.

等等?? 这是不是意味着我可以像下面这样实现异步:

```python
import urllib2

def fetch(url):
    yield urllib2.urlopen(url)
    
    
if __name__ == '__ main__':
    f = fetch('http://www.google.com')
    next(f)
    print('done')
```

如果先输出了done, 然后卡住了一会儿再结束就代表这的确是一个异步操作(想一想为什么), 但是很抱歉, 你得到了相反的结果.

其实yield和回调一样, 只是一种手段. yield只能控制代码的执行流程, 代码该执行的时候还是要执行, 它无法将一个阻塞的IO变成异步的IO, 这涉及到一点底层的知识, 我会在下节进行更深入的阐述.

## 协程与线程

线程我们已经非常熟悉了, 那么协程是什么?

yield返回的东西, 其实就是一个协程.协程本质上是一种上下文切换的技术. 如果代码中有多个协程, 我们可以自己写一个调度器来控制什么时候这个协程唤起执行什么时候那个协程休眠, 因此协程常常会伴随一个用户态级别的调度器(scheduler), 调度器会调度这些yield返回的任务.在Golang这门以协程为卖点的语言中, 直接在语言级别实现了这个调度器. 与线程相比, 协程具有以下的特点:

+   协程是单线程, 线程是多线程
+   协程不需要多线程的锁机制, 因为协程只有一个线程, 共享变量不会出现写冲突
+   协程是非抢占式的, 是由调度器自行调度多个协程, 协作式地有序完成任务, 因此叫协程, 虽然协程的执行顺序也是不可预料的,但是由于是单线程, 因此最终结果是确定的. 而线程由操作系统调度, 是抢占式的, 如果没有对数据加锁造成竞态, 无法预料数据最终的状态.
+   协程其实很早就有了, 甚至比线程还要早, 因为协程太好实现了. 但是由于协程只能使用一个线程, 并且在CPU计算的时候整个会block住, 所以没有引起大家的关注. 这些年由于web的发展, web的重IO特点非常适合协程, 因此协程又引起了人们的关注

协程模型和线程模型各有优劣, 我个人还是认为在大多数Web领域使用多线程来相应多个请求不是个好办法, 我们已经对Web领域的多线程模型做了很多优化, 比如prefork, 线程池, 然而协程在Web领域一出现就轻松打破了多线程在web领域多年来的积累, 带来了更高的资源利用率, 更大的并发, 只要你的web不涉及过多的CPU计算, 它就能工作得非常优秀. 需要注意的是, 无论是协程还是线程, 调度都是一个关键的性能优化点, 使用什么调度算法和调度策略, 如何协调多个 协程/线程 之间的运行, 都是一个难点.

一般我们都是使用协程+多进程的方式部署协程的项目, 比如在一台16核的服务器上部署16个项目实例, 确保每个核心分配一个实例, 减少由于CPU调度产生的额外资源消耗.